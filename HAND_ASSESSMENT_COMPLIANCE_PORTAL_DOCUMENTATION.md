# Hand Assessment Compliance Portal - Complete Documentation

## Overview
A streamlined patient assessment platform focused on daily compliance tracking and motion data collection. This application prioritizes ease of use for patients completing required daily assessments with simplified clinical oversight.

## Core Features Summary

### Patient Experience
- **6-digit access code login** (generated by admin)
- **Daily assessment completion tracking** (not progress-based healing metrics)
- **5 core assessments**: TAM, Kapandji, Wrist Flexion/Extension, Wrist Deviation, DASH Survey
- **Motion replay visualization** (playback only, no on-canvas calculations)
- **Simple completion status indicators**

### Clinical Admin Features
- **Patient compliance monitoring** (who's completing daily assessments)
- **Easy JSON file downloads** for motion data
- **Access code generation** for new patients
- **Patient ID management** (sequential: P001, P002, etc.)
- **Injury type assignment** during patient setup

## Technical Architecture

### Frontend Stack
```
React 18 + TypeScript
Vite (development and build)
Tailwind CSS + shadcn/ui components
Wouter (lightweight routing)
TanStack Query (API state management)
```

### Backend Stack
```
Express.js server
PostgreSQL database
Drizzle ORM
Zod validation
MediaPipe Holistic integration
```

### Database Schema
```sql
-- Simplified schema focused on compliance
portal_users (
  id SERIAL PRIMARY KEY,
  code VARCHAR(6) UNIQUE NOT NULL,
  patient_id VARCHAR(10) UNIQUE NOT NULL, -- P001, P002, etc.
  injury_type TEXT NOT NULL,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW(),
  last_visit TIMESTAMP
);

portal_assessments (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT NOT NULL,
  estimated_minutes INTEGER NOT NULL,
  order_index INTEGER NOT NULL
);

portal_user_assessments (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES portal_users(id),
  assessment_id INTEGER REFERENCES portal_assessments(id),
  completed_at TIMESTAMP DEFAULT NOW(),
  motion_data JSON,
  quality_score TEXT
);

portal_admins (
  id SERIAL PRIMARY KEY,
  username VARCHAR(50) UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

portal_access_codes (
  id SERIAL PRIMARY KEY,
  code VARCHAR(6) UNIQUE NOT NULL,
  is_used BOOLEAN DEFAULT false,
  created_at TIMESTAMP DEFAULT NOW(),
  used_at TIMESTAMP,
  used_by_user_id INTEGER REFERENCES portal_users(id)
);
```

## Project Structure

```
hand-assessment-compliance-portal/
├── package.json
├── tsconfig.json
├── vite.config.ts
├── tailwind.config.js
├── drizzle.config.ts
├── postcss.config.js
├── README.md
├── client/
│   ├── index.html
│   └── src/
│       ├── main.tsx
│       ├── App.tsx
│       ├── components/
│       │   └── ui/ (shadcn components)
│       ├── pages/
│       │   ├── patient/
│       │   │   ├── Login.tsx
│       │   │   ├── Dashboard.tsx
│       │   │   └── Assessment.tsx
│       │   └── admin/
│       │       ├── Login.tsx
│       │       ├── Dashboard.tsx
│       │       └── PatientManagement.tsx
│       ├── lib/
│       │   ├── queryClient.ts
│       │   └── utils.ts
│       └── hooks/
│           └── use-toast.ts
├── server/
│   ├── index.ts
│   ├── routes.ts
│   ├── storage.ts
│   ├── db.ts
│   ├── init-db.ts
│   └── vite.ts
└── shared/
    └── schema.ts
```

## Key Configuration Files

### package.json
```json
{
  "name": "hand-assessment-compliance-portal",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "concurrently \"npm run server\" \"npm run client\"",
    "server": "tsx watch server/index.ts",
    "client": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "db:push": "drizzle-kit push:pg"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.3.4",
    "@mediapipe/camera_utils": "^0.3.1675466862",
    "@mediapipe/control_utils": "^0.6.1629159505",
    "@mediapipe/drawing_utils": "^0.3.1620248257",
    "@mediapipe/holistic": "^0.5.1675471629",
    "@neondatabase/serverless": "^0.9.0",
    "@radix-ui/react-alert-dialog": "^1.0.5",
    "@radix-ui/react-dialog": "^1.0.5",
    "@radix-ui/react-label": "^2.0.2",
    "@radix-ui/react-select": "^2.0.0",
    "@radix-ui/react-slot": "^1.0.2",
    "@radix-ui/react-toast": "^1.1.5",
    "@tanstack/react-query": "^5.17.19",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.0",
    "concurrently": "^8.2.2",
    "drizzle-orm": "^0.29.3",
    "drizzle-zod": "^0.5.1",
    "express": "^4.18.2",
    "express-session": "^1.17.3",
    "lucide-react": "^0.309.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-hook-form": "^7.48.2",
    "tailwind-merge": "^2.2.0",
    "tsx": "^4.7.0",
    "wouter": "^2.12.1",
    "ws": "^8.16.0",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/express-session": "^1.17.10",
    "@types/node": "^20.10.6",
    "@types/react": "^18.2.47",
    "@types/react-dom": "^18.2.18",
    "@types/ws": "^8.5.10",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "drizzle-kit": "^0.20.9",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.4.0",
    "tailwindcss-animate": "^1.0.7",
    "typescript": "^5.3.3",
    "vite": "^5.0.10"
  }
}
```

### vite.config.ts
```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './client/src'),
      '@shared': path.resolve(__dirname, './shared')
    }
  },
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true
      }
    }
  }
})
```

### tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./client/src/*"],
      "@shared/*": ["./shared/*"]
    }
  },
  "include": ["client/src", "server", "shared"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
```

## Core Implementation Files

### shared/schema.ts
```typescript
import { pgTable, serial, text, varchar, timestamp, boolean, integer, json } from 'drizzle-orm/pg-core';
import { createInsertSchema } from 'drizzle-zod';
import { z } from 'zod';

// Users table (patients)
export const users = pgTable('portal_users', {
  id: serial('id').primaryKey(),
  code: varchar('code', { length: 6 }).notNull().unique(),
  patientId: varchar('patient_id', { length: 10 }).notNull().unique(),
  injuryType: text('injury_type').notNull(),
  isActive: boolean('is_active').notNull().default(true),
  createdAt: timestamp('created_at').notNull().defaultNow(),
  lastVisit: timestamp('last_visit'),
});

export const insertUserSchema = createInsertSchema(users).omit({
  id: true,
  createdAt: true,
});
export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;

// Assessments table
export const assessments = pgTable('portal_assessments', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  description: text('description').notNull(),
  estimatedMinutes: integer('estimated_minutes').notNull(),
  orderIndex: integer('order_index').notNull(),
});

export const insertAssessmentSchema = createInsertSchema(assessments).omit({
  id: true,
});
export type InsertAssessment = z.infer<typeof insertAssessmentSchema>;
export type Assessment = typeof assessments.$inferSelect;

// User Assessments table
export const userAssessments = pgTable('portal_user_assessments', {
  id: serial('id').primaryKey(),
  userId: integer('user_id').notNull().references(() => users.id),
  assessmentId: integer('assessment_id').notNull().references(() => assessments.id),
  completedAt: timestamp('completed_at').notNull().defaultNow(),
  motionData: json('motion_data'),
  qualityScore: text('quality_score'),
});

export const insertUserAssessmentSchema = createInsertSchema(userAssessments).omit({
  id: true,
  completedAt: true,
});
export type InsertUserAssessment = z.infer<typeof insertUserAssessmentSchema>;
export type UserAssessment = typeof userAssessments.$inferSelect;

// Admins table
export const admins = pgTable('portal_admins', {
  id: serial('id').primaryKey(),
  username: varchar('username', { length: 50 }).notNull().unique(),
  passwordHash: text('password_hash').notNull(),
  createdAt: timestamp('created_at').notNull().defaultNow(),
});

export const insertAdminSchema = createInsertSchema(admins).omit({
  id: true,
  createdAt: true,
});
export type InsertAdmin = z.infer<typeof insertAdminSchema>;
export type Admin = typeof admins.$inferSelect;

// Access codes table
export const accessCodes = pgTable('portal_access_codes', {
  id: serial('id').primaryKey(),
  code: varchar('code', { length: 6 }).notNull().unique(),
  isUsed: boolean('is_used').notNull().default(false),
  createdAt: timestamp('created_at').notNull().defaultNow(),
  usedAt: timestamp('used_at'),
  usedByUserId: integer('used_by_user_id').references(() => users.id),
});
```

### server/storage.ts
```typescript
import { users, admins, assessments, userAssessments, accessCodes } from "@shared/schema";
import type { User, InsertUser, Admin, InsertAdmin, Assessment, UserAssessment, InsertUserAssessment } from "@shared/schema";
import { db } from "./db";
import { eq, desc, and, gte, lt } from "drizzle-orm";

export interface IStorage {
  // User operations
  getUser(id: number): Promise<User | undefined>;
  getUserByCode(code: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  updateUserLastVisit(id: number): Promise<void>;
  
  // Admin operations
  getAdmin(id: number): Promise<Admin | undefined>;
  getAdminByUsername(username: string): Promise<Admin | undefined>;
  createAdmin(admin: InsertAdmin): Promise<Admin>;
  
  // Assessment operations
  getAssessments(): Promise<Assessment[]>;
  getUserAssessments(userId: number): Promise<UserAssessment[]>;
  createUserAssessment(assessment: InsertUserAssessment): Promise<UserAssessment>;
  getTodayCompletedAssessments(userId: number): Promise<UserAssessment[]>;
  
  // Access code operations
  generateAccessCode(): Promise<string>;
  markCodeAsUsed(code: string, userId: number): Promise<void>;
  
  // Admin functions
  getAllUsers(): Promise<User[]>;
  getComplianceData(): Promise<{
    totalPatients: number;
    activePatients: number;
    totalAssessments: number;
    completedToday: number;
  }>;
}

export class DatabaseStorage implements IStorage {
  async getUser(id: number): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user || undefined;
  }

  async getUserByCode(code: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.code, code));
    return user || undefined;
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const [user] = await db
      .insert(users)
      .values(insertUser)
      .returning();
    return user;
  }

  async updateUserLastVisit(id: number): Promise<void> {
    await db
      .update(users)
      .set({ lastVisit: new Date() })
      .where(eq(users.id, id));
  }

  async getAdmin(id: number): Promise<Admin | undefined> {
    const [admin] = await db.select().from(admins).where(eq(admins.id, id));
    return admin || undefined;
  }

  async getAdminByUsername(username: string): Promise<Admin | undefined> {
    const [admin] = await db.select().from(admins).where(eq(admins.username, username));
    return admin || undefined;
  }

  async createAdmin(insertAdmin: InsertAdmin): Promise<Admin> {
    const [admin] = await db
      .insert(admins)
      .values(insertAdmin)
      .returning();
    return admin;
  }

  async getAssessments(): Promise<Assessment[]> {
    return db.select().from(assessments).orderBy(assessments.orderIndex);
  }

  async getUserAssessments(userId: number): Promise<UserAssessment[]> {
    return db.select()
      .from(userAssessments)
      .where(eq(userAssessments.userId, userId))
      .orderBy(desc(userAssessments.completedAt));
  }

  async createUserAssessment(assessment: InsertUserAssessment): Promise<UserAssessment> {
    const [userAssessment] = await db
      .insert(userAssessments)
      .values(assessment)
      .returning();
    return userAssessment;
  }

  async getTodayCompletedAssessments(userId: number): Promise<UserAssessment[]> {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    return db.select()
      .from(userAssessments)
      .where(
        and(
          eq(userAssessments.userId, userId),
          gte(userAssessments.completedAt, today),
          lt(userAssessments.completedAt, tomorrow)
        )
      );
  }

  async generateAccessCode(): Promise<string> {
    let code: string;
    let isUnique = false;
    
    do {
      // Generate random 6-digit code
      code = Math.floor(100000 + Math.random() * 900000).toString();
      
      // Check if code already exists
      const [existingCode] = await db.select()
        .from(accessCodes)
        .where(eq(accessCodes.code, code));
        
      isUnique = !existingCode;
    } while (!isUnique);

    // Store the code
    await db.insert(accessCodes).values({ code });
    
    return code;
  }

  async markCodeAsUsed(code: string, userId: number): Promise<void> {
    await db
      .update(accessCodes)
      .set({ isUsed: true, usedAt: new Date(), usedByUserId: userId })
      .where(eq(accessCodes.code, code));
  }

  async getAllUsers(): Promise<User[]> {
    return db.select().from(users).orderBy(desc(users.createdAt));
  }

  async getComplianceData(): Promise<{
    totalPatients: number;
    activePatients: number;
    totalAssessments: number;
    completedToday: number;
  }> {
    const allUsers = await db.select().from(users);
    const activeUsers = allUsers.filter(u => u.isActive);
    const allAssessments = await db.select().from(userAssessments);
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    const todayAssessments = allAssessments.filter(a => {
      const completedAt = new Date(a.completedAt);
      return completedAt >= today && completedAt < tomorrow;
    });

    return {
      totalPatients: allUsers.length,
      activePatients: activeUsers.length,
      totalAssessments: allAssessments.length,
      completedToday: todayAssessments.length,
    };
  }
}

export const storage = new DatabaseStorage();
```

## Setup Instructions

### 1. Project Initialization
```bash
# Create new project directory
mkdir hand-assessment-compliance-portal
cd hand-assessment-compliance-portal

# Initialize package.json
npm init -y

# Install dependencies
npm install [all dependencies from package.json above]

# Install dev dependencies
npm install -D [all devDependencies from package.json above]
```

### 2. Database Setup
```bash
# Set up environment variables
echo "DATABASE_URL=your_postgres_connection_string" > .env

# Push schema to database
npm run db:push
```

### 3. Initial Data Setup
Create `server/seed.ts` to populate initial assessments:

```typescript
import { db } from './db';
import { assessments, admins } from '@shared/schema';

const initialAssessments = [
  {
    name: 'TAM (Total Active Motion)',
    description: 'Comprehensive finger flexion and extension measurement',
    estimatedMinutes: 2,
    orderIndex: 1
  },
  {
    name: 'Kapandji Test',
    description: 'Thumb opposition assessment with standardized scoring',
    estimatedMinutes: 3,
    orderIndex: 2
  },
  {
    name: 'Wrist Flexion/Extension',
    description: 'Wrist mobility measurement in sagittal plane',
    estimatedMinutes: 2,
    orderIndex: 3
  },
  {
    name: 'Wrist Radial/Ulnar Deviation',
    description: 'Wrist mobility measurement in coronal plane',
    estimatedMinutes: 2,
    orderIndex: 4
  },
  {
    name: 'DASH Survey',
    description: 'Disabilities of the Arm, Shoulder and Hand questionnaire',
    estimatedMinutes: 8,
    orderIndex: 5
  }
];

async function seed() {
  // Insert assessments
  for (const assessment of initialAssessments) {
    await db.insert(assessments).values(assessment);
  }

  // Create default admin
  await db.insert(admins).values({
    username: 'admin',
    passwordHash: 'admin123' // In production, use proper hashing
  });

  console.log('Database seeded successfully');
}

seed().catch(console.error);
```

### 4. Development Workflow
```bash
# Start development server
npm run dev

# This will start:
# - Express server on port 5000
# - Vite client on port 5173 (with API proxy)

# Access the application
# Patient portal: http://localhost:5173
# Admin portal: http://localhost:5173/admin
```

## Deployment Guide

### Environment Variables
```
DATABASE_URL=postgresql://user:password@host:port/database
NODE_ENV=production
PORT=5000
```

### Production Build
```bash
# Build for production
npm run build

# The built files will be in:
# - client/dist/ (frontend)
# - server/ (backend - no build needed, uses tsx)
```

### Hosting Recommendations
- **Frontend**: Vercel, Netlify, or any static host
- **Backend**: Railway, Render, or any Node.js host
- **Database**: Neon, Supabase, or any PostgreSQL provider

## Key Features Implementation

### Daily Compliance Tracking
- Focus on "complete today's assessments" rather than progress metrics
- Simple green/red indicators for completion status
- Encouragement messaging for daily completion

### Motion Replay (Simplified)
- Store motion data as JSON
- Simple playback visualization
- No complex on-canvas calculations
- Focus on verification of data capture

### Admin Functions
- Generate access codes with sequential patient IDs
- Download motion data as JSON files
- Monitor daily compliance rates
- Basic patient management

This documentation provides everything needed to recreate the simplified compliance portal as a standalone application focused on daily assessment completion rather than healing progress tracking.